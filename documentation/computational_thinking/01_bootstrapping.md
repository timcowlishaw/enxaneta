# Part 1: The longest "Hello World" tutorial in history.

Since we're interested in learning about computational thinking, and in doing so _through practice_, we're going to do so using a computer (although arguably this [isn't strictly necessary](https://www.i-programmer.info/programming/72-theory/3531-sorting-algorithms-as-dances.html)).


![Cover of ladybird book: "How it works: The Computer"](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_0_computer.jpg)


In addition, as broadly-STS aligned folks and infrastructure nerds, and especially ones who have a declared interest in [permacomputing](https://permacomputing.net/), we're not going to just simply "use a computer", but get really into all the detail of getting a computer ready for use, as [infrastructural inversion](https://mitpress.mit.edu/9780262522953/sorting-things-out/), but also as _commitment to the bit_ (citation forthcoming).

Keeping this detail in mind is going to help us get at a bit of a tension in what follows, possibly even an outright contradiction. On the one hand, i'm going to talk a lot about computers as _general purpose machines_, able to do very little specific apart from interpret a very abstract, general set of instructions from which we can build software to do a great variety of other more specific things (this is at the heart of the idea of computing that underlines "computational thinking"). However, I'm also going to talk about computers as massive, messy assemblages of historically and socially contingent infrastructures, a big mess of hacks, translations and details which are all incredibly specific. Can we make sense of this apparent contradiction? I think we can, and in doing so, we're going to learn about one of the most important concepts - that of **abstraction**: it's abstraction, and the layering of abstractions that allows us to treat this little bundle of silicon, copper, electricity, protocols, standards and software as if it were an abstract, general purpose computing machine, and learning to think with and work with abstractions is at the heart of the practice of programming, and the computational mode of thinking. We'll talk more about this at the end of this chapter, but for the time being, I'd just like you to keep this tension in mind, and notice it when it comes up in the text.


The computer in question is a Raspberry Pi 3 B+, which is at least 7 years old, and has previously been part of [an experimental card-game based TV interface for families](https://www.timcowlishaw.co.uk/cards.html), [a collaborative municipal data collecting installation](https://www.timcowlishaw.co.uk/extrasensory_excess.html) and [the glue connecting a receipt printer to the fediverse so people can send me silly things](https://github.com/timcowlishaw/tims-printer). This is one of the things I like about the pi, and tiny cheap computers in general - their cheapness and smallness doesn't engender disposability, but reuse - you can take the SD card out, wipe it clean, and turn it into something else incredibly simply. This might seem like a very minor thing, but as the devices we use on the regular get more and more filled with _stuff_, and maintaining (or equally decomissioning) them becomes more and more of an undertaking, there's something quite radical in this sort of general purpose but cheap device. You can set it up quickly do do one thing, and when you're done with that thing, turn it into something else, which contrasts with the more thickly-entangled way i normally relate to computers. What do we want it to do now? Well, run the python programs we're going to write, I guess, but i'm going to break that down into steps, as a bit of an excuse to provide some context to the process you're going to work through, as well as vaguely gesturing towards the various layers of infrastructure that go into making "a computer that runs python programs that we write". Therefore, we (very broadly) want the Pi to do a few things:

  - **Switch on, in a manner befitting of a computer:** This is very handwavey and a little glib, but important. We could plug the pi into the wall and a light would come on, but it wouldn't do much. Both because we've got no way of interacting with it (we're using it _headlessly_, without a keyboard, mouse, or screen of its own), but also because computer hardware, on its own, doesn't typically do very much, by definition. Computers are general-purpose devices, you _program them_ by writing software to accomplish a specific thing, then getting the computer to run that software. Without any software, the machine is basically an arrangement of intricately carved rocks. This also maybe gets at a salient point for our project, (and maybe even a provisional definition of what _computational thinking_) is: programming, to me, more than anything, is the art of taking a _specific, concrete_ thing we want a computer to do (add numbers together, make vaguely musical sounds, allow people to choose and purchase books, hold a text conversation in the style of a rogerian psychoanylist, or whatever), and finding a way of describing it in terms of more _general, abstract_ operations. This is deeply tied up with the fact that computers are general purpose machines: the elementary things they know how to do must be correspondingly general (or otherwise theyd need to be preprogrammed with maths, music, bookselling, and psychonanalysis functionality at the factory, plus whatever other thing you might anticipate them being used for). Our role as programmers is to combine these _general_ operations in such a way that they express the _specific_ thing we want the computer to do, and to do that, we need the computer not just to switch on, but to switch on, and get it to a state where we can start giving it these instructions (which involves, as i kinda gestured to before, working on top of the work of other programmers who have come before).
  - **Connect itself to WiFi:** In our particular case, since we're going to connect to the Pi over the network to give it its instructions, we're going to need it to connect to a network before we can do much with it, which means we need a way of giving it the network name and password somehow ahead of time.
  - **Allow us to connect remotely to it give instructions**: Once its on the network, we need a way of connecting to it to give it instructions, which we're going to do with something called the [Secure Shell protocol](https://en.wikipedia.org/wiki/Secure_Shell), which is normally known as _ssh_. It's a standard for accessing computers remotely via a command line interface (ie: typing commands into a screen and pressing enter, instead of clicking on things with a mouse). We'll also need a way of identifying ourselves when we connect (it's not called the _secure_ shell protocol for nothing), so we'll create an account with a username and password.
  - **Allow it to run [python](https://www.python.org/) programs specifically**: Finally, once the computer is on, online, and we're able to communicate with it, we want to run our first python program, and for this we'll need a python _interpreter_. There's lots of different programming languages, and, just as we described earlier, computers don't necessarily have an innate ability to execute all of them - a particular type of computer (or rather, a particular type of _processor_, the main component of a computer) has a specific _instruction set_ - the particular, general set of instructions it understands, and a type of program called an _interpreter_ or _compiler_ (these are actually different things, but broadly do the same job for our purposes, at least for now) translates the instructions we write in a language like python into the machine instructions understood by the particular computer we're using.

So, this is a lot of stuff that has to happen before we can start running python programs, but it's a lot of quite _general_ stuff: it doesn't really have much to do with our immediate challenge of "learning computational thinking through some practical encounters with python programming, in a vaguely permacomputing-inspire manner" but is more to do with the everyday business of "being a computer" which normally just goes on without us thinking about it much - it's _infrastructure_. This is why, most of the time we're working with computers, and even when (especially when) we're doing programming, we're building on top of other programs which do parts of what we want, and the biggest chunk of "other peoples programs" we'll encounter is probably the computer's operating system. An operating system, like MacOS, or Windows, or Android, or whatever, is basically just a collection of all these bits of taken-for-granted computeryness that it probably didn't even occur to us that we might have to deal with, like the business of reading a file from a disk, or connecting to a network, or switching on pixels on a screen in the right order to display a bit of text. The operating sytem take care of all these details for us, and provides us (and other other programs) with higher level *abstractions* that we can use in getting the computer to do what we want. That way, when we write a program that prints a message to the screen, for instance, we can simply just direct the computer to print a message to the screen, rather than directing it to switch on individual pixels, or send a particular sequence of voltages to a particular pin of a particular connector, or whatever (to be honest, I have very little idea what actually happens at this level, even after having spent a vast amount of my adult life doing "programming" in some form).

The operating system we're going to install is called *Raspbian* (or [Raspberry PI OS](https://www.raspberrypi.com/software/)), and as the name suggests, it's designed specifically for Raspberry PIs, and is a variant of [Debian](https://www.debian.org/), itself a variant of [_Linux_](https://www.linux.org/), which as insufferable nerds and pedants will almost always remind you, is actually called "[GNU/Linux](https://ast.wikipedia.org/wiki/GNU/Linux)", being a combination of the Linux _kernel_ (the minimal, central, program which allows the computer to do utterly basic things like "remember a number somewhere in its memory" and "start running a program", and a set of complimentary utilities for other basic tasks (connecting to networks, reading and writing disks, interpreting programs written in other languages) called [GNU](https://www.gnu.org/), which is short for "GNU's Not [Unix](https://en.wikipedia.org/wiki/Unix)"). Why do I mention this? Not because i'm an insufferable nerd and a pedant (although I might also be both these things), but because I think it shows us a few pertinent things. The first is that software is _always_ this sort of patchwork of existing things, and the process of making or writing software is 99% bricolage, assembling diverse components and making them fit, always in relation to other programs, projects and people (see also [the obvious xxkcd reference to make here](https://xkcd.com/2347/)).

The second is that it nicely illustates the geneology of the systems and technologies we're working with. GNU might stand for "GNU's Not Unix", but it is, in fact, part of a "Unix-like" operating system. What does this mean? Raspbian, the operating system wee're using today, arose from GNU, a project to re-write the earlier Unix family of operating systems, whose development begun in 1969. This means that the tools, systems, and interfaces you'll be working with for this project, (in common with those used by, i am pretty sure, the vast majority of programmers and computing projects today), share concepts (and actual code) with systems written and in use 55 years ago. A programmer from 1969 could sit down in front of a screen and keyboard connected to this raspberry pi, or to the servers behind pretty much any website you can think of,  and would probably be pretty familiar with them. Correspondingly, after working through this tutorial, you could probably wander into a computer lab at a 1960's university, sit down at a terminal, and have a pretty good idea of what's what.

![Illustration from the ladybird book of a man sat at a 70s computer](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_15_gdu.jpg)

It might not seem like much, but i think it's worth highlighting this contingency and geneology of our modern computer technology, especially in the context of a technology industry that so often likes to portray itself as future focused, innovative and with a schumpterian disregard for what came before. [This diagram](https://upload.wikimedia.org/wikipedia/commons/7/77/Unix_history-simple.svg) is probably worth a look - it maps out the "family tree" of UNIX-like operating systems, into which, after we've installed Raspbian, our little Pi will become enrolled.

A final related thought before we move onto the actual practical business of getting this machine running and doing things. One important detail about the weird winding geneology which led from 60s computer labs to the little circuit board you've got in front of you now: We might reasonably ask _why_, if your experience of using and programming this Raspberry Pi is so similar to that of someone sat in front of a mainframe terminal at MIT or wherever in 1969, there are so many different versions of things, and names of versions of things in between (Unix, GNU, Linux, Debian, Raspbian)? The example of when GNU (the confusingly recursively named not-UNIX) grew out of UNIX, and its reasons for doing so are germane here: the GNU project was started by a man called [Richard Stallman](https://en.wikipedia.org/wiki/Richard_Stallman), an MIT grad student and integrant of the 70s and 80s hacker culture, which in the late 70s began to atrophy as software companies became more protective of their products, seeking to prevent copying and modification of their software through agressive litigation. Stallman began GNU as a rewrite of Unix to be released as [free software](https://en.wikipedia.org/wiki/Free_software), unencumbered by copyright law, out of the belief that a freely available and modifiable version of Unix was necessary for the continued running and maintenance of existing computer systems. Say what you like about Stallman (and you could say quite a few things, such as ["he's publicly defended pedophilia!"](https://www.npr.org/2019/09/17/761718975/free-software-pioneer-quits-mit-over-his-comments-on-epstein-sex-trafficking-cas) and ["he eats bits of his own feet on stage at conferences!"](https://www.youtube.com/watch?v=zQxKURvE9iI) - he's a deeply odd and at times problematic character), but this particular belief was probably quite prescient, and highlights the fact that the geneology of development of even the most nuts-and-bolts bits of computer systems is driven by deeply sociotechnical concerns. Without Stallman and GNU, your experience of working with this raspberry pi today would probably have very little in common with the ways in which computers were used in the 1960s, and in fact the existence of cheap, open, hackable computers like the pi might not in fact have been possible at all.

Anyway, on to the practical part.

![Photo from the ladybird book of a very 70s lady inserting an enormous old fashioned disk into a no less enormous computer](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_16_disk.jpg)

The first thing we want to do then (If you've kept track during all the asides) is install the Raspbian operating system on our PI. We do that pretty much the same way itś been done since the 60s: put it on a disk, put the disk in the machine, and turn it on, except in the year of Our Lord 2024 the disk is actually a fingernail sized SD card which you'll find in the box, along with an adapter thing which it slots into and should in turn fit into a slot on your computer. Youĺl need these (the card, and the adapter):
![An image of the card and the adaptor](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_1_card_adaptor.jpg)

You can then stick the card into the adaptor, like so:

![An image of the card in the adaptor](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_2_card_in_adaptor.jpg)

At this point, check that the little slidey grey tab on the side of the adaptor is in the forward position, towards the text that says "SanDisk". This is the "write protect tab" - when its pointed backwards the memory card can only be read, which is not what we want:

![An image of the write protect tab in the forward position](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_3_card_write_protect.jpg)

Finally, take the whole card-and-adaptor assembly, and stick it into the SD card slot on your computer (the one you're reading this on, not the raspberry pi, yet):


![An image of the card in the computer](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_4_card_in_computer.jpg)

Next you'll need a copy of the raspbian operating system itself, and to get that, we use a handy programme called "Raspberry Pi Imager", which will download the correct version for us, copy it to the disk, and allow us to set up a few useful things like the WiFi in advance, so that we can then connect to the pi later without hassle. Go to [this link](https://www.raspberrypi.com/software/) to download it!

Download that and install it on your computer as you normally would, then open it up. Youĺl see a pink and white screen like the one below:


![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_5_imager_1.png)

We need to choose the type of device we're installing to, the version of the operating system we want to install, and the location of the SD card we just put in from each of the menus. Under the first, "raspberry Pi device", choose the option for "Raspberry Pi 3"


![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_6_imager_device_menu.png)

Under the second "Operating System" choose "Raspberrry Pi OS (Legacy, 32-bit)" - this is an old version, but then again, it's an old computer. Nothing wrong with that.

Finally, under the third ("Storage"), find the SD card we just plugged into the computer. I don't know exactly what this'll look like but it will probably have some combination of "SD Card" and "16GB" (or maybe a little less, 15.8GB or so) in the name. If you don't have any other disks plugged into your computer, it'll likely be the only option - if there is more than one option, check carefully, as otherwise you might overwrite something else. Probably best unplug any other disks or memory sticks or what have you to be sure (don't worry, this is the only step of the entire project where you might "break something" in a way that matters, we can relax after this).

![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_7_imager_3.png)


Click the "Next" button and you'll be asked if you want to "apply OS customisation settings" - click "Edit Settings": this is where we'll do things like provide the WiFi password so your pi knows how to connect to the internet.

![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_8_imager_customisation.png)

In the window that pops up, check the box next to "set hostname": then fill in the text field next to it to give the raspberry pi a name. We'll need this to be able to connect to it and start using it. Call it "enxaneta" perhaps (or whatever you like, but note the name down). Also check the box next to "set username and password", and give yourself a username and a password (they can be whatever you like). Finally, check the box next to "Configure wireless LAN" and add the name and password of your wifi (also make sure the "Wireless LAN country" is set to "GB" - this is something to do with spectrum and regulation and so on, wifi works differently in different countries, who knew?)


![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_9_imager_customisation_2.png)


Next, click the "services" tab at the top of the window, and check the "enable SSH" option is checked, and "use password authentication" is selected below it. This will allow us to log into the raspberry pi from your main computer and start using it.


![Screenshot of the raspberry pi imager tool](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_10_imager_customisation_3.png)

When you've done all that, click "save", then click "yes" in the "apply customisation settings" window that was waiting for you behind that one. you should see a progress bar as it writes everything to the SD card, and eventually you'll get a message saying that  everything's been written to the SD card and you can remove it. Take it out (and take the tiny card out of the adapter), and put it into the slot on the pi, then connect the power cable and plug it in!


![Screenshot of the sd card being inserted into the pi](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_11_insert_into_pi.jpg)

You should see a little red light on the side switch on, and flash for a bit, after about a minute or so the flashing should stop and we're ready to connect to the pi and start using it.


We mentioned that we were going to use something called SSH to connect to the pi from your computer, and to do that, we'll need another program, called an "ssh client". Your pi runs a piece of software called an "ssh server" which makes itself available to connections from other machines, and the client runs on your computer and knows how to talk to it - it's exactly the same principle as the web browser you're probably reading this in, which is a "client" for the HTTP protocol, through which you talk to an HTTP server on another computer. The SSH client we're going to use is called PuTTY, and you can download it by clicking the "Download PuTTY" link at [https://www.putty.org/](https://www.putty.org/)

Install PuTTY and open it, and you'll be confronted with a slightly bewildering options screen with lots of settings:

![Screenshot of the putty config screen](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_12_putty_config.png)

The only one we're interested in though is the "host name orj IP address" field, where we're going to enter the name we gave our raspberry pi a few steps back, with ".local" after it. So if you named the raspberry pi "enxaneta", you would type "enxaneta.local". Why? This is exactly like a website domain name, but the ".local" extention refers to your local network, ie everything in your house connected to your router. "enxaneta" is the name of the machine, and "local" is the name of the network to find it on, so "enxaneta.local" _should_, all being well, give PuTTY everything it needs to find our raspberry pi (I am simplifying a little here, but thatś the gist of it). Hit OK, and you'll be confronted by a typical hackers-style black and white screen, which will very likely be showing a cryptic and mildly disconcerted message along the lines of "The authenticity of host (some numbers) can be established! Here is something called a "fingerprint" which is a big long string of random numbers. Would you like to continue connecting?". This is entirely normal and is one of the things that makes SSH the "_Secure_ shell" protocol. Basically, given this is the first time you've connected to the raspberry pi, your computer has no way of telling that the computer its connecting to is who it say it is, as opposed to someone masquerading as it. If you happened to be incredibly paranoid, you could pop the SD card out of the raspberry pi and back into your computer, poke around a bit, and find somewhere on its disk a "fingerprint", and check that it matches the long string of random letters on your screen, before choosing to connect or not. However, since it is astronomically unlikely that someone has managed to get into your house and set up another computer to impersonate the raspberry pi, in order to eavesdrop on an ethnography-for-computational-thinking skills exchange, all in the space of time it's taken you to read this document and follow the instructions, we'll just type "yes" and press enter. Youĺl then be asked for your username and password (the ones we set earlier) - the password won't appear on the screen as you type it. Enter them both, and you'll then be confronted by a slightly anticlimactic bit of text that will say something like <code>\[justin@enxaneta:~\] $</code> - but this is good news - this moderately cryptic bit of text is the "command prompt" (you might also hear it called the "shell", or the "terminal"), and its were where going to be doing most of our work.  You've now succesfully got a running Raspberry Pi we can start making do things!


The command prompt is the main interface we're going to use to operate the computer "live" - its how we interact with it in day to day use, a kinda retro equivalent of the desktop on windows. To orient you a little bit, lets describe a little bit what you're looking at, and then explore a little bit about what this weird minimal interface lets us do. Going step by step, the bit before the '@', `justin` is your username, it's reminding you who you're logged in as (helpful in the case that you have multiple accounts, or if you decide to momentarily body-snatch someone else's, a thing we'll talk about later). After the '@' we have `enxaneta`, the name of the computer we're connected to, which is very useful if we're routinely remote controlling other machines (every programmer has a horror story about accidentally doing something disastrous when connected to the wrong machine, despite this helpful reminder). We've then got a colon, then a little tilde (`~`), which is a cryptic but fairly universal abreviation for "my home directory", like the linux equivalent of a "my documents folder" - so this is telling us which "directory" (basically a folder, just like on a normal computer) we're currently in. So, taken together, the bit inside the square brackets: `justin@enxaneta:~` is telling us that we're logged into the computer `enxaneta`, as the user `justin`, and we're currently sitting in `justin`'s home directory. The final dollar sign is a convention which signals where the little bit of situating information ends, and you can start to type, so lets try that out now.

We work the command prompt by typing in commands, and pressing enter. Let's try out our first one: type `ls` (all in lower case), and hit return. This'll give you a list of all the files and directories (folders) which are in the directory you're currently in (`~justin`, or justin's home, as the prompt is carefully reminding us). I don't actually have a raspberry pi at home at the moment, so i can't actually remember gets created when you first install rasbian, but you might see nothing, or you might see the typical set of folders for "Downloads", "Documents", "Music", and so on. On my laptop, you see something like this:

```
[19:25:54] [tim@bananastand:~]$ ls
Desktop   Documents   Downloads  'Dropbox (Maestral)'   Music   nixos   Shared   src   Zotero
```

It´s almost half past seven, I'm logged in as the user `tim` to a computer called [`bananastand`](https://www.smithsonianmag.com/arts-culture/the-history-of-the-frozen-banana-stand-80551198/), and I´m in my home directory, which contains some folders and files called Desktop, Documents, Downloads, 'Dropbox (Maestral)', Music, nixos, Shared, src and Zotero. I can tell they're folders (From now on i'm going to use the words "directory" and "folder" interchangably because who on earth has the time to be pedantic) because they appear in a quite pleasing blue colur for me which unfortunately doesn't translate into this document. You hopefully should also see folders on the pi in a different colour to files, but the precise colour may vary (all this shit is infinitely customisable, see also the handy clock in my prompt in the example above. I'm not going to go into how to do that just yet though as we'd never get started on the actual thing we're doing).

Let's make a folder to keep our python experiments in: Type `mkdir python_scripts` and hit enter: this runs the command `mkdir` to "MaKe a DIRectory", which we've given the name "python_scripts". Run `ls` again, and you should see it!

Now we've got a folder to do our python programming in, let's move into it so we can start working there. When you're working at the command prompt, you're always inside some folder or another, so the first important thing to learn is how to navigate around and get to where we want to be. Type `cd python_scripts`: ("Change Directory" into "python_scripts") and notice that your prompt changes from `~` to `~/python_scripts`, showing us that we're now working in the `python_scripts` folder inside your home directory. You can check out your surroundings by typing `ls` again (this is basically exactly the same principle as those nerdy 70s and 80s text video games where you'd type "GO LEFT", "LOOK AROUND" etc and get back "you see an angry orc!" or whatever, but much less entertaining) . this time you won't see much because the directory you're in is empty, as we just created it!

we should probably create a file and write some code in it, but first, one more little bit of navigational advice. to move `into` a folder, you type `cd` and the name of the folder, but i haven't told you how to move back `out` of a folder, which we'll probably want to do at some point. For this we use the 'special' folder name `..` (ie two full stops), which means "the folder up one level from where i am now". Try typing `cd ..` and pressing enter, and noticing that you've now moved back up one level to your home directory. Once you're satisfied, type `cd python_scripts` again to move back into the folder we created, then we'll get on with doing SOME PROGRAMMING (finally).

So, to recap, we now have a computer that switches on to a point where we can do things with it, we have connected to the internet, and we have connected to it remotely. The last thing we needed to do was to give it the ability to run python programs, which, happily, with raspbian, we get for free. Python is *so* ubiquitous as a programming language that most operating systems will come with a python interpreter pre-installed. We can verify this by typing `python3 --version` (running the `python3` command, passing it the switch `--verson` which means "show me what version you are then exit"):

```
[tim@bananstand:~]$ python3 --version
Python 3.11.8
```

We can see that i've got python installed, and it's version 3.11.8 (if your version varies from this one, that's absolutely fine).

If you get a message that says "python3: command not found", that's because it's called something else, or i've fucked up and its not actualy installed yet. Try `python --version` instead, and if that doesn't work, yell at me on whatsapp).

Since we've now got a python interpreter, we now have everything we need to write our first program!

When we write python programs, we store them in text files, and add the extension '.py' to the name (this is just a convention though, we could call them whatever. A lot of 'computer work' is just convention). We're going to use a text editor called [`nano`](https://www.nano-editor.org/) to write our first program, by typing the command `nano hello_world.py` (open the editor `nano`, and use it to edit the file `hello_world.py` in the current directory. It doesn't matter if this file exists or not yet, nano will create it if not at the point where we save it).

Your terminal prompt will disappear and you'll see a window like the one below!


![Screenshot of nano](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_13_nano_empty.png)


The top white bar gives us some useful information (this program is GNU nano version 7.2, we're editing "hello_world.py", and the file has been modified since we last saved it). At the bottom we see a range of commands we can run: ("Help / Write Out / Where Is" etc, with the key commands we use to run them: the little hat character `^` means the "ctrl" key, so `^G` means "ctrl and g").

In the middle is a big empty black space with a white cursor, and if we start typing, our program will appear there.

Type `print("Hello world!")` into the file!

That is the entirety of your first program (and in fact it's been [pretty much everyone's first program since at leaast 1978](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program)).

![Screenshot of nano](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_14_nano_script.png)

Hit ctrl and o (the letter o, not zero) then press enter to save the file, then ctrl and X to edit nano, you´ll end up back out at the command prompt. We can now have a go at running the program and seeing what happens! Type `python3 hello_world.py` ("run the python interpreter, and give it my hello_world.py file to interpret") and press enter, and you should see:

```
[tim@bananastand:~]$ python3 hello_world.py
Hello World!
```

...your program has `printed`  the message `Hello World!` out to the screen, which i imagine comes as a surprise to no-one, but even so we'll go back into `nano` to look at the code again in more detail: type `nano hello_world.py` again:

This seems like such a minimal program that it might seem like there's not a lot to say about it - it prints a greeting out to the screen. However, i'm gonna attempt a slightly closer analysis of it because i think it'll be instructive in a couple of respects. First to understand a little about how the language is structured, and second, to understand a little bit about what the program is doing when its run, and these two things are quite closely related.

First up, what happens when we ask python to interpet this program? python is (in general terms, at least in the form we're using it in this program) an _imperative_ programming language - it executes a series of _statements_ in order, "do this thing, then do this thing, then do this thing". Our program, rather trivially, consists of a single statement: the single line of code we're written (a statement isn't always a single line, but in this case it happens to be, and it's a good enough working approximation for now).

So, the python interpreter reads the file, and identifies the first (and only) statement: `print("Hello World!")`. Unpacking that statement, it identifies that we're referring to something called `print` - in general, where we see an alphanumeric word without quotes, its a _reference_ to the name of something previously defined. What is `print` referring to thenø? well, it has to be something built into the language (as we haven't done anything beforehand to define anything new or special), and the parentheses that follow it give us a clue about what _type_ of thing it is: it is a _function_: a definition of something that *does* something. Functions are little blocks of functionality, waiting around to be used, which take inputs (also called *arguments*), sometimes produce an output (called a *return value*) and sometimes *do something else at the same time* (called a *side-effect*). We know that *`print` is a function because we've followed it with parentheses, known as 'calling' the function. When you write the name of a function and put a pair of parentheses after it, you're saying "take this previously defined piece of functionality, and run it now!", so the fact that we're *calling the thing-called-print by suffixing it with parentheses, suggests that it must be a function.

`print` also expects some input (or an 'argument'), which we can see because there's something *inside* the parenthesesis: the message which we want it to print, in this case, the text `Hello World!`. Because this is *literal text*, rather than the name of something else , we have to enclose it in quotes: `"Hello World!"` - anything inside quotes (they can be single or double) is a *string*: a literal bit of text that we want to do something with.

So, our program is made up of a single **statement**, which passes the **string** `"Hello World!"` as an **argument** when **calling** the built-in **function** `print`, which is responsible for displaying it on the screen (a **side-effect**. Once it's done that, there's no more statements to execute, so it exits, and drops you back at your command prompt.

It's very terse, and perhaps a little bit unclear for it. We might be able to improve it by *refactoring* (programmer speak for "changing the way a progam is written, normally in order to make it clearer or more maintainable, without changing anything about what it actually does"). A possible refactor of our program might be the following:

```
greeting = "Hello World!"
print(greeting)
```

In this version of the program we've now got two statements. The first takes our **string** `"Hello World!"` and gives it a name (`greeting`) that we can refer to later ("it **assigns** it to a **variable**"). The second statement calls `print` again, and uses the variable we just defined as the argument. The result of the program (its **semantics**) are identical. I think this version is an improvement: we can more clearly see the order that things happen in, and we've separated out the business of "defining how we will greet people" from "actually greeting them", which could make things simpler to change if we wanted to, for instance, greet people multiple times with the same greeting, or provide greetings in other languages. On top of that, we've conveniently introduced the concept of _variables_, and shown (at least one of the ways) how the names-of-things we're going to invoke (like `print`) actually get defined.

To massively overthink this for a second (but in a hopefully pedagogically productive way), we could note that "the act of printing a greeting to the screen" doesn't need to know or care about what the greeting actually says, just that it exists, and as a result, our greeting variable is an **abstraction** that reflects this.

This possibly sounds a bit pretentious, but i think it's worth pointing out, as, in some sense, all of programming is the art of defining and combinging (the right) abstractions, and thinking with abstractions is fundamental to thinking computationally. In fact, plenty of people would claim that all of computation and all of programming *is* just abstaction (I plan to get us to a point where you can follow and appreciate [this talk by Tom Stuart](https://tomstu.art/programming-with-nothing) before this project is out). It also shows that a lot of programming (and programming well) has an aesthetic component: there are many different ways we _could_ write a program that prints "Hello World!" to the screen, and the art of programming is picking the appropriate one: the one that's most easily understandable, changeable or maintainable in our particular circumstances.

Also i mention it because there's another abstraction lurking here: that `print` we thoughtlessly and conveniently reached for when we printed something to the screen. Python provides us with this for free (as printing things to the screen is a very common thing to want to do in a program, and python as a language emphasises convenience and pragmatism). `print` is also an abstration, and  a rather huge one, and to see why, the incredibly belaboured process by which we've got to this point, taking in all the details of "making a computer work" from scratch, as well as the historical aspect of "where all these technologies and conventions  came from", is FINALLY going to come into play.

First off, why is the function in python that displays some text on the screen called `print`, and not `show` or `display` or something else? it's a convention, and a historical contingency: back in the 60s and 70s if you'd been doing something like this activity, instead of a screen you would have had a printer (one of those dot matrix ones with the spool of perforated paper), and your program would have **literally** printed the text onto the paper. Python here is doing the exact same thing as those historical programs, its simply outputting text to a *terminal*, which could be a printer a screen, or something else. In your case however, its not a screen nor a printer, its a **virtual terminal**, a software simulation of a thing-that-to-python appears a bit like one of those old 60s printers, which, instead of printing on paper, sends the text it receives to another program running on the same machine, which sends it over an SSH session over the WiFi network to PuTTY, running on your computer, which then displays it within a window on your desktop. `print` is itself an abstraction, built on top of hundreds of other abstractions, and presenting itself through the metaphor of an obsolute 50-year-old user interface!

![Photo from the ladybird book of people working a "mini computer system" the size of several fridges, by operating a terminal that is a printer with a keyboard](https://raw.githubusercontent.com/timcowlishaw/enxaneta/main/assets/images/ct1_17_printer.jpg)

This kinda show to me that the material, historically contingent, detail-focused side of this tutorial ("what's actually happening in the machine?, why is it like that? when did this start?") and the more classically "computational thinking" stuff (the immaterial, quasi-mathematical "what are the appropriate abstractions to use here? how can we combine and compose them?") are actually deeply interlinked, as, at heart, abstraction and computational thinking are ways of dealing with all this massive infrastructural complexity, masking it (black-boxing it?) or translating it. For this reason we're going to walk a bit of a tightrope from here on, trying to develop an awareness and appreciation for all detail and complexity, while also learning how to pragmatically ignore it all through computational thinking.

More of this in part 2, but for now lets shut down the pi.

If you're still in `nano`, hit `ctrl-o`, then `enter` then `ctrl-x` to save and then exit, then when you're back at the command prompt, type `shutdown now` (run the command `shutdown`, with the argument `now`). your putty window should close, and you can turn off the pi! We'll talk about this all more in a bit and work out where to go from here :)
